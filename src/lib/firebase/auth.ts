import {
  signInAnonymously as firebaseSignInAnonymously,
  signInWithCustomToken as firebaseSignInWithCustomToken,
  signInWithPopup,
  GoogleAuthProvider,
  type UserCredential,
} from 'firebase/auth'
import { auth } from '@/modules/config/firebase'

/**
 * Firebase error type (not exported from firebase/auth, so we define it locally)
 */
interface FirebaseError {
  code?: string
  message?: string
}

/**
 * Check if error is a Firebase configuration error
 */
function isConfigurationError(error: unknown): boolean {
  if (error && typeof error === 'object') {
    const firebaseError = error as FirebaseError
    // Check Firebase error code
    if (firebaseError.code) {
      return (
        firebaseError.code.includes('configuration-not-found') ||
        firebaseError.code.includes('CONFIGURATION_NOT_FOUND') ||
        firebaseError.code === 'auth/configuration-not-found'
      )
    }
    // Check error message
    const errorMessage = firebaseError.message || String(error)
    return (
      errorMessage.includes('CONFIGURATION_NOT_FOUND') ||
      errorMessage.includes('configuration-not-found') ||
      errorMessage.includes('400')
    )
  }
  return false
}

/**
 * Sign in anonymously using Firebase Auth
 * 
 * This creates a temporary anonymous account that can later be upgraded
 * to a permanent account via magic link.
 * 
 * @returns Promise resolving to user credential
 * @throws {Error} If sign-in fails
 */
export async function signInAnonymously(): Promise<UserCredential> {
  try {
    const credential = await firebaseSignInAnonymously(auth)
    return credential
  } catch (error) {
    // Preserve Firebase error structure for better error handling
    if (isConfigurationError(error)) {
      const configError = new Error(
        'Firebase Authentication is not configured. Please enable Anonymous Authentication in Firebase Console. See docs/FIREBASE_SETUP.md for setup instructions.'
      ) as Error & { code?: string; originalError?: unknown }
      configError.code = 'CONFIGURATION_NOT_FOUND'
      configError.originalError = error
      throw configError
    }
    
    // For other errors, preserve the original error if it's a Firebase error
    if (error && typeof error === 'object' && 'code' in error) {
      throw error
    }
    
    throw new Error(
      `Failed to sign in anonymously: ${error instanceof Error ? error.message : 'Unknown error'}`
    )
  }
}

/**
 * Send passwordless email link for authentication
 * 
 * NOTE: Magic links are generated server-side via Cloud Function.
 * This function is a placeholder for future email sending functionality.
 * In production, magic links will be generated by the generateMagicLink Cloud Function.
 * 
 * @param _email - User's email address (unused, kept for API consistency)
 * @returns Promise that resolves when email is sent
 * @throws {Error} Always throws - this should be implemented via Cloud Function
 */
export async function sendPasswordlessEmail(_email: string): Promise<void> {
  throw new Error(
    'Magic link generation is handled server-side via Cloud Function. Use the generateMagicLink Cloud Function instead.'
  )
}

/**
 * Sign in with a custom token
 * 
 * This is used when a user clicks a magic link. The token is validated
 * and then used to sign in the user with custom claims (role, roomId, etc.).
 * 
 * @param token - Custom token from magic link
 * @returns Promise resolving to user credential
 * @throws {Error} If sign-in fails
 */
export async function signInWithCustomToken(token: string): Promise<UserCredential> {
  try {
    const credential = await firebaseSignInWithCustomToken(auth, token)
    return credential
  } catch (error) {
    throw new Error(
      `Failed to sign in with custom token: ${error instanceof Error ? error.message : 'Unknown error'}`
    )
  }
}

/**
 * Verify magic link token
 * 
 * This validates a JWT token from a magic link. In production, this would
 * call a Cloud Function to verify the token. For now, we'll do basic validation.
 * 
 * @param token - JWT token from magic link
 * @returns Promise resolving to validation result
 */
export async function verifyMagicLinkToken(
  token: string
): Promise<{ valid: boolean; claims?: Record<string, unknown>; error?: string }> {
  try {
    // Basic token structure validation
    if (!token || typeof token !== 'string') {
      return { valid: false, error: 'Invalid token format' }
    }

    // Split JWT token into parts
    const parts = token.split('.')
    if (parts.length !== 3) {
      return { valid: false, error: 'Invalid JWT token format' }
    }

    // Decode payload (base64url)
    try {
      const payload = JSON.parse(atob(parts[1].replace(/-/g, '+').replace(/_/g, '/')))
      
      // Check expiration
      if (payload.exp && payload.exp < Date.now() / 1000) {
        return { valid: false, error: 'Token has expired' }
      }

      return { valid: true, claims: payload }
    } catch (decodeError) {
      return { valid: false, error: 'Failed to decode token' }
    }
  } catch (error) {
    return {
      valid: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    }
  }
}

/**
 * Sign in with Google
 * 
 * Uses Firebase Google Auth provider to sign in the user.
 * 
 * @returns Promise resolving to user credential
 * @throws {Error} If sign-in fails
 */
export async function signInWithGoogle(): Promise<UserCredential> {
  try {
    const provider = new GoogleAuthProvider()
    const credential = await signInWithPopup(auth, provider)
    return credential
  } catch (error) {
    throw new Error(
      `Failed to sign in with Google: ${error instanceof Error ? error.message : 'Unknown error'}`
    )
  }
}

/**
 * Create custom token (helper for Cloud Function integration)
 * 
 * This is a placeholder for future Cloud Function integration.
 * The actual token creation will happen server-side in a Cloud Function.
 * 
 * @param _uid - User ID (unused, kept for API consistency)
 * @param _claims - Custom claims to include in token (unused, kept for API consistency)
 * @returns Promise resolving to custom token
 * @throws {Error} Always throws - this should be called from Cloud Function
 */
export async function createCustomToken(
  _uid: string,
  _claims: Record<string, unknown>
): Promise<string> {
  throw new Error(
    'createCustomToken must be called from a Cloud Function. Use the generateMagicLink Cloud Function instead.'
  )
}

